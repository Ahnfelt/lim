compile(fs : FileSystem, moduleSources : Array[Pair[String, String]]) : Promise[Void] {
    parsedModules := map(moduleSources, p => {
        moduleName := p.first
        js"console.log('Parsing ' + moduleName);"
        tokens := lexTokens(p.second)
        pc := newPc(newTokenCursor(tokens, 0), p.second)
        Pair(p.first, parseModule(pc, "_current", "_Current", p.first, p.second))
    })
    resolver := newResolver(map(parsedModules, p => p.second))
    resolvedModules := map(parsedModules, p => {
        moduleName := p.first
        js"console.log('Resolving ' + moduleName);"
        Pair(p.first, resolveModule(resolver, p.second))
    })
    typer := newTyper(map(resolvedModules, p => p.second))
    typedModules := map(resolvedModules, p => {
        moduleName := p.first
        js"console.log('Typing ' + moduleName);"
        Pair(p.first, checkModule(typer, p.second))
    })
    builder := newStringBuilder()
    js"console.log('Emitting built-in types');"
    emitModule(builder, Module(
        package = "_prelude",
        file = "_prelude",
        alias = "_prelude",
        source = "",
        typeDefinitions = map(preludeTypeDefinitions(), p => p.second),
        functionDefinitions = []
    ))
    each(typedModules, p => {
        moduleName := p.first
        js"console.log('Emitting ' + moduleName);"
        emitModule(builder, p.second)
    })
    emitted := builder.drain
    writeTextFile(fs, "compiler.js", "\(emitted)\n\nmain();\n").map(v => {
        js"console.log('Wrote compiler.js')"
    })
}

main() {
    fs := newFileSystem()
    readDirectory(fs, "lim").then(files => {
        promiseAll(map(files, file => {
            filename := "lim/\(file)"
            readTextFile(fs, filename).map(p => Pair(file, p))
        }))
    }).then(files => {
        sortedFiles := sortByString(files, p => p.first)
        compile(fs, sortedFiles)
    }).catch(error => {
        js"console.log(error);"
    })
}
