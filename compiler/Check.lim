checkModule(typer : Typer, module : Module) : Module {
    typer.setModule(module)
    Module(
        package = module.package,
        file = module.file,
        alias = module.alias,
        source = module.source,
        typeDefinitions = module.typeDefinitions,
        functionDefinitions = map(module.functionDefinitions, d => checkFunctionDefinition(typer, d))
    )
}

checkFunctionDefinition(typer : Typer, definition : FunctionDefinition) : FunctionDefinition {
    typer.topScope({
        each(definition.signature.parameters, p => {
            typer.bindVariable(p.name, p.type)
        })
        body := checkBody(typer, definition.signature.returnType, definition.position, definition.body)
        FunctionDefinition(definition.position, definition.signature, body)
    })
}

checkBody(typer : Typer, expectedType : Type, position : Int, body : Array[Statement]) : Array[Statement] {
    if(body.size == 0, {
        equalityConstraint(typer, position, expectedType, Type.constructor(position, "Void@_", []))
        []
    }, {
        typer.scope({
            initial := map(firsts(body), s => checkStatement(typer, Type.variable(position, typer.fresh), s))
            return := orPanic(last(body))
            typedReturn := typer.expand(expectedType) ? {
                constructor(position2, symbol2, typeArguments2) {
                    if(symbol2 == "Void@_", {
                        checkStatement(typer, Type.variable(position, typer.fresh), return)
                    }, {
                        checkStatement(typer, expectedType, return)
                    })
                }
                parameter(position2, name2) {
                    checkStatement(typer, expectedType, return)
                }
                variable(position2, id2) {
                    checkStatement(typer, expectedType, return)
                }
            }
            initial.concat([typedReturn])
        })
    })
}

checkStatement(typer : Typer, expectedType : Type, statement : Statement) : Statement {
    statement ? {
        term(position, term) {
            term2 := checkTerm(typer, expectedType, term)
            Statement.term(position, term2)
        }
        let(position, variable, type, value) {
            equalityConstraint(typer, position, expectedType, Type.constructor(position, "Void@_", []))
            type2 := or(type, Type.variable(position, typer.fresh))
            value2 := checkTerm(typer, type2, value)
            typer.bindVariable(variable, typer.expand(type2))
            Statement.let(position, variable, Option.some(type2), value2)
        }
        functions(definitions) {
            position := orPanic(first(definitions)).position
            equalityConstraint(typer, position, expectedType, Type.constructor(position, "Void@_", []))
            panic("TODO: It should be possible to bind functions too, since they need a forall scheme")
            panic("each(definitions, d => resolver.addVariable(d.position, d.signature.symbol))")
            panic("Statement.functions(map(definitions, d => resolveFunctionDefinition(resolver, d, Bool.false)))")
        }
        assign(position, variable, value) {
            equalityConstraint(typer, position, expectedType, Type.constructor(position, "Void@_", []))
            value2 := checkTerm(typer, typer.variable(variable), value)
            Statement.assign(position, variable, value2)
        }
        increment(position, variable, value) {
            equalityConstraint(typer, position, expectedType, Type.constructor(position, "Void@_", []))
            value2 := checkTerm(typer, typer.variable(variable), value)
            Statement.increment(position, variable, value2)
        }
        decrement(position, variable, value) {
            equalityConstraint(typer, position, expectedType, Type.constructor(position, "Void@_", []))
            value2 := checkTerm(typer, typer.variable(variable), value)
            Statement.decrement(position, variable, value2)
        }
        ffi(position, language, code) {
            statement
        }
    }
}

checkArguments(typer : Typer, expectedType : Type, position : Int, signature : MethodSignature, arguments : Arguments) : Arguments {
    instantiation := newStringMap(map(signature.typeParameters, p => Pair(p, Type.variable(position, typer.fresh))))
    parameterTypes := map(signature.parameters, p => typer.instantiate(instantiation, p.type))
    returnType := typer.instantiate(instantiation, signature.returnType)
    namedParameters := map(signature.parameters.drop(arguments.unnamed.size()), p => p.name)
    unnamed := map(zip(parameterTypes, arguments.unnamed), p => {
        checkTerm(typer, p.first, p.second)
    })
    named := map(zip(parameterTypes.drop(arguments.unnamed.size), namedParameters), p => {
        find(arguments.named, a => a.name == p.second) ? {
            some(a) {
                NamedArgument(a.order, p.second, checkTerm(typer, p.first, a.value))
            }
            none {
                typer.error(position, "Missing argument: \(p.second)")
            }
        }
    })
    when(unnamed.size + named.size < parameterTypes.size, { typer.error(position, "Too few arguments") })
    when(unnamed.size + named.size > parameterTypes.size, { typer.error(position, "Too many arguments") })
    equalityConstraint(typer, position, expectedType, returnType)
    Arguments(unnamed, named)
}

checkTerm(typer : Typer, expectedType : Type, term : Term) : Term {
    term ? {
        binary(position, operator, left, right) { panic("TODO") }
        unary(position, operator, value) { panic("TODO") }
        codeUnitValue(position, value) { panic("TODO") }
        textValue(position, value) { panic("TODO") }
        textLiteral(position, parts) { panic("TODO") }
        integerValue(position, value) { panic("TODO") }
        floatingValue(position, value) { panic("TODO") }
        arrayValue(position, elements) { panic("TODO") }
        instance(position, symbol, thisName, methods) { panic("TODO") }
        match(position, value, cases) { panic("TODO") }
        lambda(position, parameters, body) { panic("TODO") }
        ffiJs(position, code) { term }
        functionCall(position, methodName, arguments) {
            signature := typer.function(methodName).signature
            typedArguments := checkArguments(typer, expectedType, position, signature, arguments)
            Term.functionCall(position, methodName, typedArguments)
        }
        staticCall(position, symbol, methodName, arguments) {
            signature := panic("TODO")
            typedArguments := checkArguments(typer, expectedType, position, signature, arguments)
            Term.staticCall(position, symbol, methodName, typedArguments)
        }
        methodCall(position, value, methodName, arguments) {
            signature := panic("TODO")
            typedArguments := checkArguments(typer, expectedType, position, signature, arguments)
            Term.methodCall(position, value, methodName, typedArguments)
        }
        variable(position, symbol) {
            type := typer.variable(symbol)
            equalityConstraint(typer, position, expectedType, type)
            term
        }
    }
}
