Term ? {
    binary(position : Int, operator : TokenType, left : Term, right : Term)
    unary(position : Int, operator : TokenType, value : Term)
    codeUnitValue(position : Int, value : String)
    textValue(position : Int, value : String)
    textLiteral(position : Int, parts : Array[Term])
    integerValue(position : Int, value : String)
    floatingValue(position : Int, value : String)
    arrayValue(position : Int, elements : Array[Term])
    classOrModule(position : Int, module : Option[String], classOrModule : String)
    thisModule(position : Int)
    variable(position : Int, name : String)
    methodCall(position : Int, value : Term, methodName : String, arguments : Array[Term], namedArguments : Array[NamedArgument])
    instance(position : Int, moduleName : Option[String], interfaceName : String, thisName : Option[String], methods : Array[MethodImplementation])
    match(position : Int, value : Term, cases : Array[MatchCase])
    lambda(position : Int, parameters : Array[String], body : Array[Statement])
    native(position : Int, operation : NativeOperation)
    ffiJs(position : Int, code : String)
}

MatchCase(body : MethodImplementation, fieldNames : Array[String])

NamedArgument(order : Int, name : String, value : Term)

NativeOperation ? {
    arrayAccess(value : Term, index : Term)
    fieldAccess(value : Term, fieldName : String)
    functionCall(value : Term, arguments : Array[Term])
    toString(value : Term)
    bool(value : Bool)
    if(condition : Term, thenBody : Array[Statement], elseBody : Array[Statement])
}

Statement ? {
    term(position : Int, term : Term)
    let(position : Int, variable : String, variableType : Option[Type], value : Term)
    function(definition : FunctionDefinition)
    assign(position : Int, variable : String, value : Term)
    increment(position : Int, variable : String, value : Term)
    decrement(position : Int, variable : String, value : Term)
    ffi(position : Int, language : String, code : String)
}


Type ? {
    constructor(position : Int, module : Option[String], name : String, typeArguments : Array[Type])
    parameter(position : Int, name : String)
    variable(position : Int, id : Int)
}

TypeDefinition(position : Int, name : String, typeParameters : Array[String], isSum : Bool, methodSignatures : Array[MethodSignature])
FunctionDefinition(position : Int, signature : MethodSignature, body : Array[Statement])

MethodSignature(position : Int, name : String, typeParameters : Array[String], parameters : Array[Parameter], returnType : Type)

MethodImplementation(position : Int, name : String, parameters : Array[String], body : Array[Statement])

Parameter(position : Int, name : String, parameterType : Type)


Module(
    typeDefinitions : Array[TypeDefinition],
    functionDefinitions : Array[FunctionDefinition]
)

Import(position : Int, moduleName : String, symbol : ExportedSymbol)

ExportedSymbol(position : Int, name : String, everything : Bool)
