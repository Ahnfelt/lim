Term ? {
    binary(offset : Int, operator : TokenType, left : Term, right : Term)
    unary(offset : Int, operator : TokenType, value : Term)
    codeUnitValue(offset : Int, value : String)
    textValue(offset : Int, value : String)
    textLiteral(offset : Int, parts : Array[Term])
    integerValue(offset : Int, value : String)
    floatingValue(offset : Int, value : String)
    arrayValue(offset : Int, elements : Array[Term])
    classOrModule(offset : Int, module : Option[String], classOrModule : String)
    thisModule(offset : Int)
    variable(offset : Int, name : String)
    methodCall(offset : Int, value : Term, methodName : String, arguments : Array[Term], namedArguments : Array[NamedArgument])
    instance(offset : Int, moduleName : Option[String], interfaceName : String, thisName : Option[String], methods : Array[MethodImplementation])
    match(offset : Int, value : Term, cases : Array[MatchCase])
    lambda(offset : Int, parameters : Array[String], body : Array[Statement])
    native(offset : Int, operation : NativeOperation)
    ffiJs(offset : Int, code : String)
}

MatchCase(body : MethodImplementation, fieldNames : Array[String])

NamedArgument(order : Int, name : String, value : Term)

NativeOperation ? {
    arrayAccess(value : Term, index : Term)
    fieldAccess(value : Term, fieldName : String)
    functionCall(value : Term, arguments : Array[Term])
    toString(value : Term)
    bool(value : Bool)
    if(condition : Term, thenBody : Array[Statement], elseBody : Array[Statement])
}

Statement ? {
    term(offset : Int, term : Term)
    let(offset : Int, variable : String, variableType : Option[Type], value : Term)
    function(definition : FunctionDefinition)
    assign(offset : Int, variable : String, value : Term)
    increment(offset : Int, variable : String, value : Term)
    decrement(offset : Int, variable : String, value : Term)
    ffi(offset : Int, language : String, code : String)
}


Type ? {
    constructor(offset : Int, module : Option[String], name : String, typeArguments : Array[Type])
    parameter(offset : Int, name : String)
    variable(offset : Int, id : Int)
}

TypeDefinition(offset : Int, name : String, typeParameters : Array[String], isSum : Bool, methodSignatures : Array[MethodSignature])
FunctionDefinition(offset : Int, signature : MethodSignature, body : Array[Statement])

MethodSignature(offset : Int, name : String, typeParameters : Array[String], parameters : Array[Parameter], returnType : Type)

MethodImplementation(offset : Int, name : String, parameters : Array[String], body : Array[Statement])

Parameter(offset : Int, name : String, parameterType : Type)


Module(
    typeDefinitions : Array[TypeDefinition],
    functionDefinitions : Array[FunctionDefinition]
)

Import(offset : Int, moduleName : String, symbol : ExportedSymbol)

ExportedSymbol(offset : Int, name : String, everything : Bool)
