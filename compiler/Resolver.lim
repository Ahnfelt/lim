resolveModule(resolver : Resolver, module : Module) : Module {
    resolver.setSource(module.source)
    Module(
        package = module.package,
        file = module.file,
        alias = module.alias,
        source = module.source,
        typeDefinitions = map(module.typeDefinitions, d => resolveTypeDefinition(resolver, d)),
        functionDefinitions = map(module.functionDefinitions, d => resolveFunctionDefinition(resolver, d))
    )
}

resolveTypeDefinition(resolver : Resolver, d : TypeDefinition) : TypeDefinition {
    resolver.scope({
        symbol := resolver.typeConstructor(d.position, d.symbol)
        typeParameters := map(d.typeParameters, p => resolver.addTypeParameter(d.position, p))
        methodSignatures := map(d.methodSignatures, s => resolveMethodSignatureInScope(resolver, s))
        TypeDefinition(d.position, symbol, typeParameters, d.isSum, methodSignatures)
    })
}

resolveFunctionDefinition(resolver : Resolver, d : FunctionDefinition) : FunctionDefinition {
    resolver.scope({
        signature := resolveMethodSignatureInScope(resolver, d.signature)
        body := resolveBody(resolver, d.body)
        FunctionDefinition(d.position, signature, body)
    })
}

resolveMethodSignatureInScope(resolver : Resolver, s : MethodSignature) : MethodSignature {
    typeParameters := map(s.typeParameters, p => resolver.addTypeParameter(s.position, p))
    parameters := map(s.parameters, p => { Parameter(p.position, resolver.addVariable(p.position, p.name), resolveType(resolver, p.type)) })
    returnType := resolveType(resolver, s.returnType)
    MethodSignature(s.position, s.symbol, s.typeParameters, parameters, returnType)
}

resolveMethodImplementation(resolver : Resolver, i : MethodImplementation) : MethodImplementation {
    resolver.scope({
        parameters := map(i.parameters, p => resolver.addVariable(i.position, p))
        body := resolveBody(resolver, i.body)
        MethodImplementation(i.position, i.name, parameters, body)
    })
}

resolveMatchCase(resolver : Resolver, case : MatchCase) : MatchCase {
    MatchCase(resolveMethodImplementation(resolver, case.body), case.fieldNames)
}

resolveBody(resolver : Resolver, body : Array[Statement]) : Array[Statement] {
    resolver.scope({
        map(body, s => resolveStatement(resolver, s))
    })
}

resolveStatement(resolver : Resolver, statement : Statement) : Statement {
    statement ? {
        term(position, term) {
            Statement.term(position, resolveTerm(resolver, term))
        }
        let(position, variable, type, value) {
            resolver.assertNoVariable(position, variable)
            resolver.addVariable(position, variable)
            variableType := type ? {
                some(t) { Option.some(resolveType(resolver, t)) }
                none { Option.none }
            }
            Statement.let(position, resolver.variable(position, variable), variableType, resolveTerm(resolver, value))
        }
        functions(definitions) {
            each(definitions, d => resolver.addVariable(d.position, d.signature.symbol))
            Statement.functions(map(definitions, d => resolveFunctionDefinition(resolver, d)))
        }
        assign(position, variable, value) {
            Statement.assign(position, resolver.variable(position, variable), resolveTerm(resolver, value))
        }
        increment(position, variable, value) {
            Statement.increment(position, resolver.variable(position, variable), resolveTerm(resolver, value))
        }
        decrement(position, variable, value) {
            Statement.decrement(position, resolver.variable(position, variable), resolveTerm(resolver, value))
        }
        ffi(position, language, code) {
            Statement.ffi(position, language, code)
        }
    }
}

resolveType(resolver : Resolver, type : Type) : Type {
    type ? {
        constructor(position, symbol, typeArguments) {
            resolvedSymbol := resolver.typeConstructor(position, symbol)
            resolvedTypeArguments := map(typeArguments, a => resolveType(resolver, a))
            Type.constructor(position, resolvedSymbol, resolvedTypeArguments)
        }
        parameter(position, name) {
            Type.parameter(position, resolver.typeParameter(position, name))
        }
        variable(position, id) {
            type
        }
    }
}

resolveTerm(resolver : Resolver, term : Term) : Term {
    term ? {
        binary(position, operator, left, right) {
            Term.binary(position, operator, resolveTerm(resolver, left), resolveTerm(resolver, right))
        }
        unary(position, operator, value) {
            Term.unary(position, operator, resolveTerm(resolver, value))
        }
        codeUnitValue(position, value) { term }
        textValue(position, value) { term }
        textLiteral(position, parts) {
            Term.textLiteral(position, map(parts, p => resolveTerm(resolver, p)))
        }
        integerValue(position, value) { term }
        floatingValue(position, value) { term }
        arrayValue(position, elements) {
            Term.arrayValue(position, map(elements, e => resolveTerm(resolver, e)))
        }
        thisModule(position) { term }
        variable(position, symbol) {
            Term.variable(position, resolver.variable(position, symbol))
        }
        staticCall(position, symbol, methodName, arguments) {
            resolvedSymbol := resolver.staticName(position, symbol)
            resolvedArguments := map(arguments.unnamed, a => resolveTerm(resolver, a))
            resolvedNamedArguments := map(arguments.named, a => NamedArgument(a.order, a.name, resolveTerm(resolver, a.value)))
            Term.staticCall(position, resolvedSymbol, methodName, Arguments(resolvedArguments, resolvedNamedArguments))
        }
        methodCall(position, value, methodName, arguments) {
            resolvedValue := resolveTerm(resolver, value)
            resolvedArguments := map(arguments.unnamed, a => resolveTerm(resolver, a))
            resolvedNamedArguments := map(arguments.named, a => NamedArgument(a.order, a.name, resolveTerm(resolver, a.value)))
            Term.methodCall(position, resolvedValue, methodName, Arguments(resolvedArguments, resolvedNamedArguments))
        }
        instance(position, symbol, thisName, methods) {
            thisName ? { some(n) { resolver.addVariable(position, n) }; none { "" } }
            resolvedSymbol := resolver.typeConstructor(position, symbol)
            resolvedMethods := map(methods, i => resolveMethodImplementation(resolver, i))
            Term.instance(position, resolvedSymbol, thisName, resolvedMethods)
        }
        match(position, value, cases) {
            resolvedValue := resolveTerm(resolver, value)
            resolvedCases := map(cases, c => resolveMatchCase(resolver, c))
            Term.match(position, resolvedValue, resolvedCases)
        }
        lambda(position, parameters, body) {
            resolver.scope({
                resolvedParameters := map(parameters, p => resolver.addVariable(position, p))
                resolvedBody := resolveBody(resolver, body)
                Term.lambda(position, resolvedParameters, resolvedBody)
            })
        }
        ffiJs(position, code) { term }
    }
}

Resolver {
    typeConstructor(position : Int, symbol : String) : String
    variable(position : Int, symbol : String) : String
    typeParameter(position : Int, symbol : String) : String
    staticName(position : Int, symbol : String) : String
    assertNoVariable(position : Int, name : String) : Void
    addVariable(position : Int, name : String) : String
    addTypeParameter(position : Int, name : String) : String
    scope[t](body : () => t) : t
    setSource(text : String)
}

newResolver(modules : Array[Module]) : Resolver {
    source := ""
    error := (e, p) => {
        panic("\(e) \(positionText(newCharCursor(source), p))")
    }

    preludeTypes := ["Void", "Bool", "String", "Int", "Float", "Array", "Option", "Pair", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9"]
    modulePreludeTypes := map(preludeTypes, t => "_.\(t)")
    canonicalPreludeTypes := map(preludeTypes, t => "\(t)@_")
    preludeTypeConstructors := zip(preludeTypes.concat(modulePreludeTypes), canonicalPreludeTypes.concat(canonicalPreludeTypes))

    allTypes := flatten(map(modules, m => map(m.typeDefinitions, d => Pair(d.symbol, "\(d.symbol)@\(m.package)"))))
    allFunctions := flatten(map(modules, m => map(m.functionDefinitions, d => Pair(d.signature.symbol, "\(d.signature.symbol)@\(m.package)"))))

    definedTypes := newStringMapBuilder([])
    definedFunctions := newStringMapBuilder([])
    each(modules, m => {
        source = m.source
        each(m.typeDefinitions, d => {
            unique := "\(d.symbol)@\(m.package)"
            when(definedTypes.has(unique), { error("Duplicate type definition: \(d.symbol)", d.position) })
            definedTypes.set(unique, Bool.true)
        })
    })
    each(modules, m => {
        source = m.source
        each(m.functionDefinitions, d => {
            unique := "\(d.signature.symbol)@\(m.package)"
            when(definedFunctions.has(unique), { error("Duplicate function definition: \(d.signature.symbol)", d.position) })
            definedFunctions.set(unique, Bool.true)
        })
    })

    typeConstructors := newStringMapBuilder(preludeTypeConstructors.concat(allTypes))
    functions := newStringMapBuilder(allFunctions)
    moduleAliases := newStringMapBuilder(map(modules, m => Pair(m.alias, "\(m.package)")))
    moduleTypeConstructors := newStringMapBuilder(flatten(map(modules, m => map(m.typeDefinitions, d => Pair("\(m.alias).\(d.symbol)", "\(d.symbol)@\(m.package)")))))

    variables := newStringMapBuilder([])
    typeParameters := newStringMapBuilder([])

    Resolver {
        typeConstructor(position, symbol) {
            typeConstructors.get(symbol) ? {
                some(x) { x }
                none {
                    moduleTypeConstructors.get(symbol) ? {
                        some(x) { x }
                        none { error("No such type: \(symbol)", position) }
                    }
                }
            }
        }
        typeParameter(position, symbol) {
            typeParameters.get(symbol) ? {
                some(x) { x }
                none { error("No such type parameter: \(symbol)", position) }
            }
        }
        staticName(position, symbol) {
            typeConstructors.get(symbol) ? {
                some(x) { x }
                none {
                    moduleAliases.get(symbol) ? {
                        some(x) { x }
                        none {
                            moduleTypeConstructors.get(symbol) ? {
                                some(x) { x }
                                none { error("No such module or type: \(symbol)", position) }
                            }
                        }
                    }
                }
            }
        }
        variable(position, symbol) {
            variables.get(symbol) ? {
                some(x) { x }
                none {
                    functions.get(symbol) ? {
                        none { error("No such variable or function: \(symbol)", position) }
                        some(x) { x }
                    }
                }
            }
        }
        assertNoVariable(position, name) {
            when(variables.has(name), { error("Suspicious shadowing of variable: \(name)", position) })
        }
        addVariable(position, name) {
            variables.set(name, name)
            name
        }
        addTypeParameter(position, name) {
            typeParameters.get(name) ? {
                some(n) { error("Suspicious shadowing of type parameter: \(name)", position) }
                none { "" }
            }
            typeParameters.set(name, name)
            name
        }
        scope(body) {
            savedTypeConstructors := typeConstructors.toArray
            savedVariables := variables.toArray
            savedTypeParameters := typeParameters.toArray
            result := body()
            typeConstructors = newStringMapBuilder(savedTypeConstructors)
            variables = newStringMapBuilder(savedVariables)
            typeParameters = newStringMapBuilder(savedTypeParameters)
            result
        }
        setSource(text) {
            source = text
        }
    }
}
