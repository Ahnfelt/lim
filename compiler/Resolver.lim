resolveModule(resolver : Resolver, module : Module) : Module {
    Module(
        package = module.package,
        file = module.file,
        typeDefinitions = map(module.typeDefinitions, d => resolveTypeDefinition(resolver, d)),
        functionDefinitions = map(module.functionDefinitions, d => resolveFunctionDefinition(resolver, d))
    )
}

resolveTypeDefinition(resolver : Resolver, d : TypeDefinition) : TypeDefinition {
    resolver.scope({
        symbol := resolver.typeConstructor(d.position, d.symbol)
        typeParameters := map(d.typeParameters, p => resolver.addTypeParameter(d.position, p))
        methodSignatures := map(d.methodSignatures, s => resolveMethodSignatureInScope(resolver, s))
        TypeDefinition(d.position, symbol, typeParameters, d.isSum, methodSignatures)
    })
}

resolveFunctionDefinition(resolver : Resolver, d : FunctionDefinition) : FunctionDefinition {
    resolver.scope({
        signature := resolveMethodSignatureInScope(resolver, d.signature)
        body := resolveBody(resolver, d.body)
        FunctionDefinition(d.position, signature, body)
    })
}

resolveMethodSignatureInScope(resolver : Resolver, s : MethodSignature) : MethodSignature {
    symbol := resolver.variable(s.position, s.symbol)
    typeParameters := map(s.typeParameters, p => resolver.addTypeParameter(s.position, p))
    parameters := map(s.parameters, p => { Parameter(p.position, resolver.addVariable(p.position, p.name), resolveType(resolver, p.type)) })
    returnType := resolveType(resolver, s.returnType)
    MethodSignature(s.position, symbol, s.typeParameters, parameters, returnType)
}

resolveBody(resolver : Resolver, body : Array[Statement]) : Array[Statement] {
    map(body, s => resolveStatement(resolver, s))
}

resolveStatement(resolver : Resolver, statement : Statement) : Statement {
    statement ? {
        term(position, term) {
            Statement.term(position, resolveTerm(resolver, term))
        }
        let(position, variable, type, value) {
            resolver.scope({
                resolver.addVariable(position, variable)
                variableType := type ? {
                    some(t) { Option.some(resolveType(resolver, t)) }
                    none { Option.none }
                }
                Statement.let(position, resolver.variable(position, variable), variableType, resolveTerm(resolver, value))
            })
        }
        function(definition) {
            Statement.function(resolveFunctionDefinition(resolver, definition))
        }
        assign(position, variable, value) {
            Statement.assign(position, resolver.variable(position, variable), resolveTerm(resolver, value))
        }
        increment(position, variable, value) {
            Statement.increment(position, resolver.variable(position, variable), resolveTerm(resolver, value))
        }
        decrement(position, variable, value) {
            Statement.decrement(position, resolver.variable(position, variable), resolveTerm(resolver, value))
        }
        ffi(position, language, code) {
            Statement.ffi(position, language, code)
        }
    }
}

resolveType(resolver : Resolver, type : Type) : Type {
    type ? {
        constructor(position, symbol, typeArguments) {
            resolvedSymbol := resolver.typeConstructor(position, symbol)
            resolvedTypeArguments := map(typeArguments, a => resolveType(resolver, a))
            Type.constructor(position, resolvedSymbol, resolvedTypeArguments)
        }
        parameter(position, name) {
            Type.parameter(position, resolver.typeParameter(position, name))
        }
        variable(position, id) {
            type
        }
    }
}

resolveTerm(resolver : Resolver, term : Term) : Term {
    term ? {
        binary(position, operator, left, right) {
            Term.binary(position, operator, resolveTerm(resolver, left), resolveTerm(resolver, right))
        }
        unary(position, operator, value) {
            Term.unary(position, operator, resolveTerm(resolver, value))
        }
        codeUnitValue(position, value) { term }
        textValue(position, value) { term }
        textLiteral(position, parts) {
            Term.textLiteral(position, map(parts, p => resolveTerm(resolver, p)))
        }
        integerValue(position, value) { term }
        floatingValue(position, value) { term }
        arrayValue(position, elements) {
            Term.arrayValue(position, map(elements, e => resolveTerm(resolver, e)))
        }
        thisModule(position) { term }
        variable(position, symbol) {
            Term.variable(position, resolver.variable(position, symbol))
        }
        staticCall(position, symbol, methodName, arguments) {
            panic("TODO")
            Term.staticCall(position, symbol, methodName, arguments)
        }
        methodCall(position, value, methodName, arguments) {
            resolvedValue := resolveTerm(resolver, value)
            resolvedArguments := map(arguments.unnamed, a => resolveTerm(resolver, a))
            resolvedNamedArguments := map(arguments.named, a => NamedArgument(a.order, a.name, resolveTerm(resolver, a.value)))
            Term.methodCall(position, resolvedValue, methodName, Arguments(resolvedArguments, resolvedNamedArguments))
        }
        instance(position, symbol, thisName, methods) {
            panic("TODO")
        }
        match(position, value, cases) {
            panic("TODO")
        }
        lambda(position, parameters, body) {
            resolver.scope({
                resolvedParameters := map(parameters, p => resolver.addVariable(position, p))
                resolvedBody := resolveBody(resolver, body)
                Term.lambda(position, resolvedParameters, resolvedBody)
            })
        }
        ffiJs(position, code) { term }
    }
}

Resolver {
    typeConstructor(position : Int, symbol : String) : String
    variable(position : Int, symbol : String) : String
    typeParameter(position : Int, symbol : String) : String
    addVariable(position : Int, name : String) : String
    addTypeParameter(position : Int, name : String) : String
    scope[t](body : () => t) : t
}

newResolver(modules : Array[Module]) : Resolver {
    typeConstructors := newStringMapBuilder(flatten(map(modules, m => map(m.typeDefinitions, d => Pair(d.symbol, "\(m.package).\(d.symbol)")))))
    variables := newStringMapBuilder(flatten(map(modules, m => map(m.functionDefinitions, d => Pair(d.signature.symbol, "\(m.package).\(d.signature.symbol)")))))
    typeParameters := newStringMapBuilder([])
    Resolver {
        typeConstructor(position, symbol) {
            typeConstructors.get(symbol) ? {
                none { panic("No such type: \(symbol)") }
                some(x) { x }
            }
        }
        typeParameter(position, symbol) {
            typeParameters.get(symbol) ? {
                none { panic("No such type parameter: \(symbol)") }
                some(x) { x }
            }
        }
        variable(position, symbol) {
            variables.get(symbol) ? {
                none { panic("No such variable: \(symbol)") }
                some(x) { x }
            }
        }
        addVariable(position, name) {
            variables.set(name, name)
            name
        }
        addTypeParameter(position, name) {
            typeParameters.set(name, name)
            name
        }
        scope(body) {
            savedTypeConstructors := typeConstructors
            savedVariables := variables
            savedTypeParameters := typeParameters
            result := body()
            typeConstructors = savedTypeConstructors
            variables = savedVariables
            typeParameters = savedTypeParameters
            result
        }
    }
}
