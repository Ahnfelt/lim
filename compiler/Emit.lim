emitModule(builder : StringBuilder, module : Module) {
    each(module.typeDefinitions, d => {
        emitTypeDefinition(builder, d)
        builder.append("\n")
    })
    each(module.functionDefinitions, d => {
        emitFunctionDefinition(builder, d)
        builder.append("\n")
    })
}

emitTypeDefinition(builder : StringBuilder, definition : TypeDefinition) {
    when(definition.isSum, {
        name := baseName(definition.symbol)
        builder.append("var \(escapeUpper(name)) = {\n")
        first := Bool.true
        each(definition.methodSignatures, s => {
            when(!first, { builder.append(",\n") })
            first = Bool.false
            when(s.parameters.size == 0, {
                builder.append("\(escapeMethod(s.symbol))_k: {_: \(escapeString(s.symbol))},\n")
            })
            builder.append("\(escapeMethod(s.symbol)): function(")
            builder.append(join(map(s.parameters, p => escapeVariable(p.name)), ", "))
            builder.append(") {\n")
            if(s.parameters.size == 0, {
                builder.append("return \(escapeUpper(name)).\(escapeMethod(s.symbol))_k;\n")
            }, {
                builder.append("return {_: \(escapeString(s.symbol))")
                builder.append(join(map(s.parameters, p => ", \(escapeMethod(p.name)): \(escapeVariable(p.name))"), ""))
                builder.append("};\n")
            })
            builder.append("}")
        })
        builder.append("\n};\n")
    })
}

emitFunctionDefinition(builder : StringBuilder, definition : FunctionDefinition) {
    name := baseName(definition.signature.symbol)
    parameters := join(map(definition.signature.parameters, p => escapeVariable(p.name)), ", ")
    builder.append("function \(escapeMethod(name))(\(parameters)) {\n")
    emitBody(builder, definition.body)
    builder.append("}\n")
}

emitBody(builder : StringBuilder, body : Array[Statement]) {
    firsts := body.take(body.size - 1)
    lasts := body.drop(body.size - 1)
    each(firsts, s => emitStatement(builder, s, Bool.false))
    each(lasts, s => emitStatement(builder, s, Bool.true))
}

emitStatement(builder : StringBuilder, statement : Statement, return : Bool) {
    statement ? {
        term(position, term) {
            when(return, { builder.append("return ") })
            emitTerm(builder, term)
            builder.append(";\n")
        }
        let(position, variable, type, value) {
            builder.append("var \(escapeVariable(variable)) = ")
            emitTerm(builder, value)
            builder.append(";\n")
        }
        functions(definitions) {
            each(definitions, d => emitFunctionDefinition(builder, d))
        }
        assign(position, variable, value) {
            builder.append("\(escapeVariable(variable)) = ")
            emitTerm(builder, value)
            builder.append(";\n")
        }
        increment(position, variable, value) {
            builder.append("\(escapeVariable(variable)) += ")
            emitTerm(builder, value)
            builder.append(";\n")
        }
        decrement(position, variable, value) {
            builder.append("\(escapeVariable(variable)) -= ")
            emitTerm(builder, value)
            builder.append(";\n")
        }
        ffi(position, language, code) {
            builder.append(code)
            builder.append("\n")
        }
    }
}

emitArguments(builder : StringBuilder, arguments : Arguments) {
    builder.append("(")
    panic("TODO")
    builder.append(")")
}

emitTerm(builder : StringBuilder, term : Term) {
    term ? {
        binary(position, operator, left, right) {
            emitTerm(builder, left)
            builder.append(" ")
            done := Bool.false
            when(operator == TokenType.star, { builder.append("*"); done = Bool.true })
            when(operator == TokenType.slash, { builder.append("/"); done = Bool.true })
            when(operator == TokenType.plus, { builder.append("+"); done = Bool.true })
            when(operator == TokenType.minus, { builder.append("-"); done = Bool.true })
            when(operator == TokenType.equal, { builder.append("=="); done = Bool.true })
            when(operator == TokenType.notEqual, { builder.append("!="); done = Bool.true })
            when(operator == TokenType.less, { builder.append("<"); done = Bool.true })
            when(operator == TokenType.lessEqual, { builder.append("<="); done = Bool.true })
            when(operator == TokenType.greater, { builder.append(">"); done = Bool.true })
            when(operator == TokenType.greaterEqual, { builder.append(">="); done = Bool.true })
            when(operator == TokenType.and, { builder.append("&&"); done = Bool.true })
            when(operator == TokenType.or, { builder.append("||"); done = Bool.true })
            when(!done, { panic("Unknown binary operator") })
            builder.append(" ")
            emitTerm(builder, right)
        }
        unary(position, operator, value) {
            done := Bool.false
            when(operator == TokenType.minus, { builder.append("-"); done = Bool.true })
            when(operator == TokenType.exclamation, { builder.append("!"); done = Bool.true })
            when(!done, { panic("Unknown unary operator") })
            emitTerm(builder, value)
        }
        codeUnit(position, value) {
            panic("TODO")
        }
        text(position, value) {
            builder.append(escapeString(value))
        }
        textLiteral(position, parts) {
            first := Bool.true
            when(parts.size > 1, { builder.append("(") })
            each(parts, p => {
                when(!first, { builder.append(" + ") })
                first = Bool.false
                emitTerm(builder, p)
            })
            when(parts.size > 1, { builder.append(")") })
        }
        integer(position, value) {
            builder.append(value)
        }
        floating(position, value) {
            builder.append(value)
        }
        array(position, elements) {
            first := Bool.true
            builder.append("[")
            each(elements, e => {
                when(!first, { builder.append(", ") })
                first = Bool.false
                emitTerm(builder, e)
            })
            builder.append("]")
        }
        record(position, fields) {
            first := Bool.true
            builder.append("{")
            each(fields, f => {
                when(!first, { builder.append(", ") })
                first = Bool.false
                builder.append("\(escapeMethod(f.label)): ")
                emitTerm(builder, f.value)
            })
            builder.append("}")
        }
        instance(position, symbol, thisName, methods) {
            panic("TODO")
        }
        match(position, value, cases) {
            panic("TODO")
        }
        lambda(position, parameters, body) {
            ps := join(map(parameters, p => escapeVariable(p)), ", ")
            builder.append("(function(\(ps)) {\n")
            emitBody(builder, body)
            builder.append("})")
        }
        functionCall(position, methodName, arguments) {
            builder.append(escapeMethod(methodName))
            emitArguments(builder, arguments)
        }
        staticCall(position, symbol, methodName, arguments) {
            name := baseName(symbol)
            builder.append("\(escapeUpper(symbol)).\(escapeMethod(methodName))")
            emitArguments(builder, arguments)
        }
        methodCall(position, value, methodName, arguments) {
            emitTerm(builder, value)
            builder.append(".\(escapeMethod(methodName))")
            emitArguments(builder, arguments)
        }
        variable(position, symbol) {
            builder.append(escapeVariable(symbol))
        }
    }
}

escapeVariable(name : String) : String {
    if(reservedWords().has(name), { "\(name)_" }, { name })
}

escapeMethod(name : String) : String {
    if(reservedWords().has(name), { "\(name)_" }, { name })
}

escapeUpper(name : String) : String {
    name
}

escapeString(value : String) : String {
    js"console.log('TODO: Escape strings')"
    "\"\(value)\""
}

reservedWords() : StringMap[Bool] {
    newStringMap(map([
        "arguments",
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield",
        "enum",
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        "await"
    ], w => Pair(w, Bool.true)))
}

baseName(name : String) : String {
    js"return name.replace(/[@].*/, '');"
}
