parseCommaList[t](pc : Pc, parse : () => t, end : TokenType) : Array[t] {
    result := newArrayBuilder()
    while({
        pc.lookahead("comma separated list", [
            Pair([end], { Bool.false }),
            Pair([], { Bool.true })
        ])
    }, {
        result.push(parse())
        pc.lookahead("comma", [
            Pair([end], { }),
            Pair([], { pc.consume(TokenType.comma) })
        ])
    })
    result.drain
}

parseTypeConstructor(pc : Pc) : Type {
    position := pc.position
    moduleName := pc.lookahead("type constructor", [
        Pair([TokenType.upper, TokenType.dot], {
            name := pc.consume(TokenType.upper)
            pc.consume(TokenType.dot)
            Option.some(name)
        }),
        Pair([], { Option.none })
    ])
    name := pc.consume(TokenType.upper)
    typeArguments := pc.lookahead("type arguments", [
         Pair([TokenType.leftSquare], {
             pc.consume(TokenType.leftSquare)
             result := parseCommaList(pc, { parseType(pc) }, TokenType.rightSquare)
             pc.consume(TokenType.rightSquare)
             result
         }),
         Pair([], { [] })
     ])
     Type.constructor(position, moduleName, name, typeArguments)
}

parseType(pc : Pc) : Type {
    pc.lookahead("type", [
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            typeArguments := parseCommaList(pc, { parseType(pc) }, TokenType.rightRound)
            pc.consume(TokenType.rightRound)
            position := pc.position
            pc.consume(TokenType.rightThickArrow)
            returnType := parseType(pc)
            Type.constructor(position, Option.none, "F\(typeArguments.size.toString)", typeArguments.concat([returnType]))
        }),
        Pair([TokenType.lower], {
            position := pc.position
            name := pc.consume(TokenType.lower)
            Type.parameter(position, name)
        }),
        Pair([], { parseTypeConstructor(pc) })
    ])
}

parseLambda(pc : Pc) : Term {
    position := pc.position
    pc.lookahead("lambda function", [
        Pair([TokenType.leftCurly], {
            body := parseBody(pc)
            Term.lambda(position, [], body)
        }),
        Pair([], {
            parameters := pc.lookahead("lambda function", [
                Pair([TokenType.lower], {
                    [pc.consume(TokenType.lower)]
                }),
                Pair([TokenType.leftRound], {
                    pc.consume(TokenType.leftRound)
                    result := parseCommaList(pc, { pc.consume(TokenType.lower) }, TokenType.rightRound)
                    pc.consume(TokenType.rightRound)
                    result
                })
            ])
            pc.consume(TokenType.rightThickArrow)
            body := pc.lookahead("lambda body", [
                Pair([TokenType.leftCurly], {
                    parseBody(pc)
                }),
                Pair([], {
                    [Statement.term(position, parseTerm(pc))]
                })
            ])
            Term.lambda(position, parameters, body)
        })
    ])
}

parseMethodImplementation(pc : Pc) : MethodImplementation {
    position := pc.position
    name := pc.consume(TokenType.lower)
    parameters := pc.lookahead("method parameter", [
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            result := parseCommaList(pc, { pc.consume(TokenType.lower) }, TokenType.rightRound)
            pc.consume(TokenType.rightRound)
            result
        }),
        Pair([], { [] })
    ])
    body := parseBody(pc)
    MethodImplementation(position, name, parameters, body)
}

parseMethodImplementations(pc : Pc, allowThisName : Bool) : Pair[Option[String], Array[MethodImplementation]] {
    pc.consume(TokenType.leftCurly)
    thisName := if(!allowThisName, { Option.none }, {
        pc.lookahead("this =>", [
            Pair([TokenType.lower, TokenType.rightThickArrow], {
                name := pc.consume(TokenType.lower)
                pc.consume(TokenType.rightThickArrow)
                Option.some(name)
            }),
            Pair([], { Option.none })
        ])
    })
    result := newArrayBuilder()
    while({
        pc.lookahead("method implementation", [
            Pair([TokenType.separator, TokenType.rightCurly], {
                pc.consume(TokenType.separator)
                pc.consume(TokenType.rightCurly)
                Bool.false
            }),
            Pair([TokenType.rightCurly], {
                pc.consume(TokenType.rightCurly)
                Bool.false
            }),
            Pair([TokenType.separator], {
                pc.consume(TokenType.separator)
                Bool.true
            }),
            Pair([], { Bool.true })
        ])
    }, {
        result.push(parseMethodImplementation(pc))
    })
    Pair(thisName, result.drain)
}

parseInstance(pc : Pc) : Term {
    position := pc.position
    moduleName := pc.lookahead("type constructor", [
        Pair([TokenType.upper, TokenType.dot], {
            name := pc.consume(TokenType.upper)
            pc.consume(TokenType.dot)
            Option.some(name)
        }),
        Pair([], { Option.none })
    ])
    name := pc.consume(TokenType.upper)
    pair := parseMethodImplementations(pc, Bool.true)
    Term.instance(position, moduleName, name, pair.first, pair.second)
}

parseArray(pc : Pc) : Term {
    position := pc.position
    pc.consume(TokenType.leftSquare)
    elements := parseCommaList(pc, { parseTerm(pc) }, TokenType.rightSquare)
    pc.consume(TokenType.rightSquare)
    Term.arrayValue(position, elements)
}

parseAtom(pc : Pc) : Term {
    pc.lookahead("atom", [
        Pair([TokenType.leftSquare], { parseArray(pc) }),
        Pair([TokenType.lower, TokenType.rightThickArrow], { parseLambda(pc) }),
        Pair([TokenType.leftRound, TokenType.lower, TokenType.comma], { parseLambda(pc) }),
        Pair([TokenType.leftRound, TokenType.lower, TokenType.rightRound, TokenType.rightThickArrow], { parseLambda(pc) }),
        Pair([TokenType.leftRound, TokenType.rightRound, TokenType.rightThickArrow], { parseLambda(pc) }),
        Pair([TokenType.leftCurly], { parseLambda(pc) }),
        Pair([TokenType.upper, TokenType.leftCurly], { parseInstance(pc) }),
        Pair([TokenType.upper, TokenType.dot, TokenType.upper, TokenType.leftCurly], { parseInstance(pc) }),
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            result := parseTerm(pc)
            pc.consume(TokenType.rightRound)
            result
        }),
        Pair([TokenType.upper, TokenType.dot, TokenType.upper], {
            module := pc.consume(TokenType.upper)
            pc.consume(TokenType.dot)
            position := pc.position
            class := pc.consume(TokenType.upper)
            pc.consume(TokenType.rightRound)
            Term.classOrModule(position, Option.some(module), class)
        }),
        Pair([TokenType.upper], {
            position := pc.position
            class := pc.consume(TokenType.upper)
            pc.consume(TokenType.rightRound)
            Term.classOrModule(position, Option.none, class)
        }),
        Pair([TokenType.lower], {
            position := pc.position
            name := pc.consume(TokenType.lower)
            Term.variable(position, name)
        }),
        Pair([TokenType.codeUnit], {
            position := pc.position
            codeUnit := pc.consume(TokenType.codeUnit)
            Term.codeUnitValue(position, codeUnit)
        }),
        Pair([TokenType.text], {
            position := pc.position
            text := pc.consume(TokenType.text)
            Term.textValue(position, text)
        }),
        Pair([TokenType.textStart], {
            parseText(pc)
        }),
        Pair([TokenType.numeral], {
            position := pc.position
            value := pc.consume(TokenType.numeral)
            Term.integerValue(position, value)
        }),
        Pair([TokenType.floating], {
            position := pc.position
            value := pc.consume(TokenType.floating)
            Term.floatingValue(position, value)
        })
    ])
}

parseText(pc : Pc) : Term {
    position := pc.position
    parts := newArrayBuilder()
    firstText := pc.consume(TokenType.textStart)
    when(firstText.size > 0, { parts.push(Term.textValue(position, firstText)) })
    done := Bool.false
    while({ !done }, {
        parts.push(parseTerm(pc))
        pc.lookahead("end of string", [
            Pair([TokenType.textEnd], {
                text := pc.consume(TokenType.textEnd)
                when(text.size > 0, { parts.push(Term.textValue(position, text)) })
                done = Bool.true
            }),
            Pair([TokenType.textMiddle], {
                text := pc.consume(TokenType.textMiddle)
                when(text.size > 0, { parts.push(Term.textValue(position, text)) })
            })
        ])
    })
    Term.textLiteral(position, parts.drain)
}

parseTerm(pc : Pc) : Term {
    panic("TODO")
}

parseFfi(pc : Pc) : Statement {
    position := pc.position
    language := pc.consume(TokenType.lower)
    when(language != "js", { panic("Expected FFI js, got FFI \(language)") })
    code := pc.consume(TokenType.text)
    Statement.ffi(position, language, code)
}

parseBody(pc : Pc) : Array[Statement] {
    panic("TODO")
}
