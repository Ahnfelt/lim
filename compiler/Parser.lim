parseCommaList[t](pc : Pc, parse : () => t, end : TokenType) : Array[t] {
    result := newArrayBuilder()
    while({
        pc.lookahead("comma separated list", [
            Pair([end], { Bool.false }),
            Pair([], { Bool.true })
        ])
    }, {
        result.push(parse())
        pc.lookahead("comma", [
            Pair([end], { }),
            Pair([], { pc.consume(TokenType.comma) })
        ])
    })
    result.drain
}

parseLeftAssociative(pc : Pc, next : () => Term, operators : Array[TokenType]) : Term {
    result := next()
    cases := map(operators, o => Pair([o], {
        position := pc.position
        pc.consume(o)
        result = Term.binary(position, o, result, next())
        Bool.true
    })).concat([Pair([], { Bool.false })])
    while({ pc.lookahead("operator", cases) }, {})
    result
}

parseTypeConstructor(pc : Pc) : Type {
    position := pc.position
    moduleName := pc.lookahead("type constructor", [
        Pair([TokenType.upper, TokenType.dot], {
            name := pc.consume(TokenType.upper)
            pc.consume(TokenType.dot)
            Option.some(name)
        }),
        Pair([], { Option.none })
    ])
    name := pc.consume(TokenType.upper)
    typeArguments := pc.lookahead("type arguments", [
         Pair([TokenType.leftSquare], {
             pc.consume(TokenType.leftSquare)
             result := parseCommaList(pc, { parseType(pc) }, TokenType.rightSquare)
             pc.consume(TokenType.rightSquare)
             result
         }),
         Pair([], { [] })
     ])
     Type.constructor(position, moduleName, name, typeArguments)
}

parseType(pc : Pc) : Type {
    pc.lookahead("type", [
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            typeArguments := parseCommaList(pc, { parseType(pc) }, TokenType.rightRound)
            pc.consume(TokenType.rightRound)
            position := pc.position
            pc.consume(TokenType.rightThickArrow)
            returnType := parseType(pc)
            Type.constructor(position, Option.none, "F\(typeArguments.size.toString)", typeArguments.concat([returnType]))
        }),
        Pair([TokenType.lower], {
            position := pc.position
            name := pc.consume(TokenType.lower)
            Type.parameter(position, name)
        }),
        Pair([], { parseTypeConstructor(pc) })
    ])
}

parseLambda(pc : Pc) : Term {
    position := pc.position
    pc.lookahead("lambda function", [
        Pair([TokenType.leftCurly], {
            body := parseBody(pc)
            Term.lambda(position, [], body)
        }),
        Pair([], {
            parameters := pc.lookahead("lambda function", [
                Pair([TokenType.lower], {
                    [pc.consume(TokenType.lower)]
                }),
                Pair([TokenType.leftRound], {
                    pc.consume(TokenType.leftRound)
                    result := parseCommaList(pc, { pc.consume(TokenType.lower) }, TokenType.rightRound)
                    pc.consume(TokenType.rightRound)
                    result
                })
            ])
            pc.consume(TokenType.rightThickArrow)
            body := pc.lookahead("lambda body", [
                Pair([TokenType.leftCurly], {
                    parseBody(pc)
                }),
                Pair([], {
                    [Statement.term(position, parseTerm(pc))]
                })
            ])
            Term.lambda(position, parameters, body)
        })
    ])
}

parseMethodImplementation(pc : Pc) : MethodImplementation {
    position := pc.position
    name := pc.consume(TokenType.lower)
    parameters := pc.lookahead("method parameter", [
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            result := parseCommaList(pc, { pc.consume(TokenType.lower) }, TokenType.rightRound)
            pc.consume(TokenType.rightRound)
            result
        }),
        Pair([], { [] })
    ])
    body := parseBody(pc)
    MethodImplementation(position, name, parameters, body)
}

parseMethodImplementations(pc : Pc, allowThisName : Bool) : Pair[Option[String], Array[MethodImplementation]] {
    pc.consume(TokenType.leftCurly)
    thisName := if(!allowThisName, { Option.none }, {
        pc.lookahead("this =>", [
            Pair([TokenType.lower, TokenType.rightThickArrow], {
                name := pc.consume(TokenType.lower)
                pc.consume(TokenType.rightThickArrow)
                Option.some(name)
            }),
            Pair([], { Option.none })
        ])
    })
    result := newArrayBuilder()
    while({
        pc.lookahead("method implementation", [
            Pair([TokenType.separator, TokenType.rightCurly], {
                pc.consume(TokenType.separator)
                pc.consume(TokenType.rightCurly)
                Bool.false
            }),
            Pair([TokenType.rightCurly], {
                pc.consume(TokenType.rightCurly)
                Bool.false
            }),
            Pair([TokenType.separator], {
                pc.consume(TokenType.separator)
                Bool.true
            }),
            Pair([], { Bool.true })
        ])
    }, {
        result.push(parseMethodImplementation(pc))
    })
    Pair(thisName, result.drain)
}

parseInstance(pc : Pc) : Term {
    position := pc.position
    moduleName := pc.lookahead("type constructor", [
        Pair([TokenType.upper, TokenType.dot], {
            name := pc.consume(TokenType.upper)
            pc.consume(TokenType.dot)
            Option.some(name)
        }),
        Pair([], { Option.none })
    ])
    name := pc.consume(TokenType.upper)
    pair := parseMethodImplementations(pc, Bool.true)
    Term.instance(position, moduleName, name, pair.first, pair.second)
}

parseArray(pc : Pc) : Term {
    position := pc.position
    pc.consume(TokenType.leftSquare)
    elements := parseCommaList(pc, { parseTerm(pc) }, TokenType.rightSquare)
    pc.consume(TokenType.rightSquare)
    Term.arrayValue(position, elements)
}

parseAtom(pc : Pc) : Term {
    pc.lookahead("atom", [
        Pair([TokenType.leftSquare], { parseArray(pc) }),
        Pair([TokenType.lower, TokenType.rightThickArrow], { parseLambda(pc) }),
        Pair([TokenType.leftRound, TokenType.lower, TokenType.comma], { parseLambda(pc) }),
        Pair([TokenType.leftRound, TokenType.lower, TokenType.rightRound, TokenType.rightThickArrow], { parseLambda(pc) }),
        Pair([TokenType.leftRound, TokenType.rightRound, TokenType.rightThickArrow], { parseLambda(pc) }),
        Pair([TokenType.leftCurly], { parseLambda(pc) }),
        Pair([TokenType.upper, TokenType.leftCurly], { parseInstance(pc) }),
        Pair([TokenType.upper, TokenType.dot, TokenType.upper, TokenType.leftCurly], { parseInstance(pc) }),
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            result := parseTerm(pc)
            pc.consume(TokenType.rightRound)
            result
        }),
        Pair([TokenType.upper, TokenType.dot, TokenType.upper], {
            module := pc.consume(TokenType.upper)
            pc.consume(TokenType.dot)
            position := pc.position
            class := pc.consume(TokenType.upper)
            pc.consume(TokenType.rightRound)
            Term.classOrModule(position, Option.some(module), class)
        }),
        Pair([TokenType.upper], {
            position := pc.position
            class := pc.consume(TokenType.upper)
            pc.consume(TokenType.rightRound)
            Term.classOrModule(position, Option.none, class)
        }),
        Pair([TokenType.lower], {
            position := pc.position
            name := pc.consume(TokenType.lower)
            Term.variable(position, name)
        }),
        Pair([TokenType.codeUnit], {
            position := pc.position
            codeUnit := pc.consume(TokenType.codeUnit)
            Term.codeUnitValue(position, codeUnit)
        }),
        Pair([TokenType.text], {
            position := pc.position
            text := pc.consume(TokenType.text)
            Term.textValue(position, text)
        }),
        Pair([TokenType.textStart], {
            parseText(pc)
        }),
        Pair([TokenType.numeral], {
            position := pc.position
            value := pc.consume(TokenType.numeral)
            Term.integerValue(position, value)
        }),
        Pair([TokenType.floating], {
            position := pc.position
            value := pc.consume(TokenType.floating)
            Term.floatingValue(position, value)
        })
    ])
}

parseText(pc : Pc) : Term {
    position := pc.position
    parts := newArrayBuilder()
    firstText := pc.consume(TokenType.textStart)
    when(firstText.size > 0, { parts.push(Term.textValue(position, firstText)) })
    done := Bool.false
    while({ !done }, {
        parts.push(parseTerm(pc))
        pc.lookahead("end of string", [
            Pair([TokenType.textEnd], {
                text := pc.consume(TokenType.textEnd)
                when(text.size > 0, { parts.push(Term.textValue(position, text)) })
                done = Bool.true
            }),
            Pair([TokenType.textMiddle], {
                text := pc.consume(TokenType.textMiddle)
                when(text.size > 0, { parts.push(Term.textValue(position, text)) })
            })
        ])
    })
    Term.textLiteral(position, parts.drain)
}

parseNamedArgument(pc : Pc) : Pair[String, Term] {
    name := pc.consume(TokenType.lower)
    pc.consume(TokenType.assign)
    term := parseTerm(pc)
    Pair(name, term)
}

parseCall(pc : Pc) : Term {
    result := parseAtom(pc)
    while({ pc.lookahead("method", [
        Pair([TokenType.leftRound], { Bool.true }),
        Pair([TokenType.dot], { Bool.true }),
        Pair([], { Bool.false })
    ]) }, {
        named := Bool.false
        position := pc.position
        methodName := pc.lookahead("method name", [
            Pair([TokenType.dot], { pc.consume(TokenType.dot); pc.consume(TokenType.lower) }),
            Pair([], { "invoke" })
        ])
        result = pc.lookahead("method call", [
            Pair([TokenType.leftRound], {
                pc.consume(TokenType.leftRound)
                arguments := parseCommaList(pc, { pc.lookahead("method argument", [
                    Pair([TokenType.lower, TokenType.assign], {
                        named = Bool.true
                        name := pc.consume(TokenType.lower);
                        pc.consume(TokenType.assign)
                        Pair(name, parseTerm(pc))
                    }),
                    Pair([], {
                        when(named, { panic("Unexpected unnamed argument after named argument") })
                        Pair("", parseTerm(pc))
                    })
                ])}, TokenType.rightRound)
                pc.consume(TokenType.rightRound)
                Term.methodCall(position, result, methodName,
                    arguments = map(filter(arguments, a => a.first == ""), a => a.second),
                    namedArguments = map(indexed(filter(arguments, a => a.first != "")), i => NamedArgument(i.first, i.second.first, i.second.second))
                )
            }),
            Pair([], {
                 Term.methodCall(position, result, methodName, [], [])
            })
        ])
    })
    result
}

parseMinusNot(pc : Pc) : Term {
    position := pc.position
    pc.lookahead("unary operator", [
        Pair([TokenType.minus], {
            pc.consume(TokenType.minus)
            Term.unary(position, TokenType.minus, parseCall(pc))
        }),
        Pair([TokenType.exclamation], {
            pc.consume(TokenType.exclamation)
            Term.unary(position, TokenType.exclamation, parseCall(pc))
        }),
        Pair([], { parseCall(pc) })
    ])
}

parseTimesDivide(pc : Pc) : Term { parseLeftAssociative(pc, { parseMinusNot(pc) }, [TokenType.star, TokenType.slash]) }
parsePlusMinus(pc : Pc) : Term { parseLeftAssociative(pc, { parseTimesDivide(pc) }, [TokenType.plus, TokenType.minus]) }
parseInequality(pc : Pc) : Term { parseLeftAssociative(pc, { parsePlusMinus(pc) }, [TokenType.equal, TokenType.notEqual, TokenType.less, TokenType.lessEqual, TokenType.greater, TokenType.greaterEqual]) }
parseAndOr(pc : Pc) : Term { parseLeftAssociative(pc, { parseInequality(pc) }, [TokenType.and, TokenType.or]) }

parseMatch(pc : Pc) : Term {
    value := parseAndOr(pc)
    pc.lookahead("match", [
        Pair([TokenType.question], {
            position := pc.position
            pc.consume(TokenType.question)
            cases := parseMethodImplementations(pc, Bool.false)
            Term.match(position, value, map(cases.second, m => MatchCase(m, [])))
        }),
        Pair([], {
            value
        })
    ])
}

parseTerm(pc : Pc) : Term { parseMatch(pc) }

parseFfi(pc : Pc) : Statement {
    position := pc.position
    language := pc.consume(TokenType.lower)
    when(language != "js", { panic("Expected FFI js, got FFI \(language)") })
    code := pc.consume(TokenType.text)
    Statement.ffi(position, language, code)
}

parseBody(pc : Pc) : Array[Statement] {
    pc.consume(TokenType.leftCurly)
    result := newArrayBuilder()
    while({ pc.lookahead("statement or }", [
        Pair([TokenType.rightCurly], { pc.consume(TokenType.rightCurly); Bool.false }),
        Pair([TokenType.separator, TokenType.rightCurly], { pc.consume(TokenType.separator); pc.consume(TokenType.rightCurly); Bool.false }),
        Pair([TokenType.separator], { pc.consume(TokenType.separator); Bool.true }),
        Pair([], { Bool.true })
    ]) }, {
        result.push(parseStatement(pc))
        pc.lookahead("line break, ';' or '}'", [
            Pair([TokenType.rightCurly], {}),
            Pair([TokenType.separator], {})
        ])
    })
    result.drain
}

parseStatement(pc : Pc) : Statement {
    position := pc.position
    pc.lookahead("statement", [
        Pair([TokenType.lower, TokenType.leftRound, TokenType.rightRound, TokenType.leftCurly], { Statement.function(parseFunctionDefinition(pc)) }),
        Pair([TokenType.lower, TokenType.leftRound, TokenType.rightRound, TokenType.colon], { Statement.function(parseFunctionDefinition(pc)) }),
        Pair([TokenType.lower, TokenType.leftRound, TokenType.lower, TokenType.colon], { Statement.function(parseFunctionDefinition(pc)) }),
        Pair([TokenType.lower, TokenType.colon], {
            name := pc.consume(TokenType.lower)
            pc.consume(TokenType.colon)
            type := pc.lookahead("type", [
                Pair([TokenType.assign], { Option.none }),
                Pair([], { Option.some(parseType(pc)) })
            ])
            pc.consume(TokenType.assign)
            value := parseTerm(pc)
            Statement.let(position, name, type, value)
        }),
        Pair([TokenType.lower, TokenType.assign], {
            name := pc.consume(TokenType.lower)
            pc.consume(TokenType.assign)
            value := parseTerm(pc)
            Statement.assign(position, name, value)
        }),
        Pair([TokenType.lower, TokenType.increment], {
            name := pc.consume(TokenType.lower)
            pc.consume(TokenType.increment)
            value := parseTerm(pc)
            Statement.increment(position, name, value)
        }),
        Pair([TokenType.lower, TokenType.decrement], {
            name := pc.consume(TokenType.lower)
            pc.consume(TokenType.decrement)
            value := parseTerm(pc)
            Statement.decrement(position, name, value)
        }),
        Pair([TokenType.lower, TokenType.text], {
            parseFfi(pc)
        }),
        Pair([TokenType.lower, TokenType.assign], {
            term := parseTerm(pc)
            Statement.term(position, term)
        })
    ])
}

parseTypeParameter(pc : Pc) : String {
    pc.consume(TokenType.lower)
}

parseParameter(pc : Pc) : Parameter {
    position := pc.position
    name := pc.consume(TokenType.lower)
    pc.consume(TokenType.colon)
    type := parseType(pc)
    Parameter(position, name, type)
}

parseMethodSignature(pc : Pc) : MethodSignature {
    position := pc.position
    name := pc.consume(TokenType.lower)
    typeParameters := pc.lookahead("type parameters", [
        Pair([TokenType.leftSquare], {
            pc.consume(TokenType.leftSquare)
            result := parseCommaList(pc, { parseTypeParameter(pc) }, TokenType.rightSquare)
            pc.consume(TokenType.rightSquare)
            result
        }),
        Pair([], { [] })
    ])
    parameters := pc.lookahead("parameters", [
        Pair([TokenType.leftRound], {
            pc.consume(TokenType.leftRound)
            result := parseCommaList(pc, { parseParameter(pc) }, TokenType.rightRound)
            pc.consume(TokenType.rightRound)
            result
        }),
        Pair([], { [] })
    ])
    returnType := pc.lookahead("return type", [
        Pair([TokenType.colon], {
            pc.consume(TokenType.colon)
            parseType(pc)
        }),
        Pair([], { Type.constructor(position, Option.none, "Void", []) })
    ])
    MethodSignature(position, name, typeParameters, parameters, returnType)
}

parseFunctionDefinition(pc : Pc) : FunctionDefinition {
    position := pc.position
    signature := parseMethodSignature(pc)
    body := parseBody(pc)
    FunctionDefinition(position, signature, body)
}

parseMethodSignatures(pc : Pc) : Array[MethodSignature] {
    pc.consume(TokenType.leftCurly)
    result := newArrayBuilder()
    while({ pc.lookahead("method signature or }", [
        Pair([TokenType.rightCurly], { pc.consume(TokenType.rightCurly); Bool.false }),
        Pair([TokenType.separator, TokenType.rightCurly], { pc.consume(TokenType.separator); pc.consume(TokenType.rightCurly); Bool.false }),
        Pair([TokenType.separator], { pc.consume(TokenType.separator); Bool.true }),
        Pair([], { Bool.true })
    ]) }, {
        result.push(parseMethodSignature(pc))
        pc.lookahead("line break, ';' or '}'", [
            Pair([TokenType.rightCurly], {}),
            Pair([TokenType.separator], {})
        ])
    })
    result.drain
}

parseTypeDefinition(pc : Pc) : TypeDefinition {
    position := pc.position
    name := pc.consume(TokenType.upper)
    typeParameters := pc.lookahead("type parameters", [
        Pair([TokenType.leftSquare], {
            pc.consume(TokenType.leftSquare)
            result := parseCommaList(pc, { parseTypeParameter(pc) }, TokenType.rightSquare)
            pc.consume(TokenType.rightSquare)
            result
        }),
        Pair([], { [] })
    ])
    isSum := pc.lookahead("type parameters", [
        Pair([TokenType.question], {
            pc.consume(TokenType.question)
            Bool.true
        }),
        Pair([], { Bool.false })
    ])
    methodSignatures := pc.lookahead("method signatures", [
        Pair([TokenType.leftRound], {
            methodPosition := position
            pc.consume(TokenType.leftRound)
            parameters := parseCommaList(pc, { parseParameter(pc) }, TokenType.rightRound)
            pc.consume(TokenType.rightRound)
            methodName := "\(name.take(1).toLower)\(name.drop(1))"
            [MethodSignature(methodPosition, methodName, [], parameters, Type.constructor(methodPosition, Option.none, "Void", []))]
        }),
        Pair([], { parseMethodSignatures(pc) })
    ])
    TypeDefinition(position, name, typeParameters, isSum, methodSignatures)
}

parseModule(pc : Pc) : Module {
    typeDefinitions := newArrayBuilder()
    functionDefinitions := newArrayBuilder()
    while({ pc.lookahead("definition or end of file", [
        Pair([TokenType.outsideFile], { Bool.false }),
        Pair([TokenType.separator, TokenType.outsideFile], { pc.consume(TokenType.separator); Bool.false }),
        Pair([TokenType.separator], { pc.consume(TokenType.separator); Bool.true }),
        Pair([], { Bool.true })
    ]) }, {
        pc.lookahead("definition", [
            Pair([TokenType.lower], { functionDefinitions.push(parseFunctionDefinition(pc)) }),
            Pair([], { typeDefinitions.push(parseTypeDefinition(pc)) })
        ])
        pc.lookahead("line break", [
            Pair([TokenType.outsideFile], {}),
            Pair([TokenType.separator], {})
        ])
    })
    Module(
        typeDefinitions = typeDefinitions.drain,
        functionDefinitions = functionDefinitions.drain
    )
}

testParser() {
    program := "1 + 2"
    tokens := lexTokens(program)
    pc := newPc(newTokenCursor(tokens, 0), program)
    result := parseTerm(pc)
    js"console.dir(result);"
}
