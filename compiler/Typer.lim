Typer {
    scope[a](body : () => a) : a
    topScope[a](body : () => a) : a
    type(name : String) : TypeDefinition
    variable(name : String) : Type
    function(name : String) : FunctionDefinition
    bindFunction(name : String, definition : FunctionDefinition)
    bindVariable(name : String, type : Type)
    bindTypeVariable(position : Int, id : Int, type : Type)
    occursCheck(position : Int, id : Int, outerType : Type, type : Type)
    fresh() : Int
    expand(type : Type) : Type
    instantiate(instantiation : StringMap[Type], type : Type) : Type
    setModule(newModule : Module)
    error[a](position : Int, problem : String) : a
}

newTyper(modules : Array[Module]) : Typer {
    types := newStringMapBuilder(flatten(map(modules, m => map(m.typeDefinitions, d => Pair(d.symbol, d)))))
    functions := newStringMapBuilder(flatten(map(modules, m => map(m.functionDefinitions, d => Pair(d.signature.symbol, d)))))
    variables := newStringMapBuilder([])
    substitution := newStringMapBuilder([])
    nextId := 0
    module := modules(0)
    Typer { typer =>
        scope(body) {
            oldVariables := variables.toArray
            oldFunctions := functions.toArray
            result := body()
            variables = newStringMapBuilder(oldVariables)
            functions = newStringMapBuilder(oldFunctions)
            result
        }
        topScope(body) {
            result := typer.scope(body)
            substitution = newStringMapBuilder([])
            nextId = 0
            result
        }
        type(name) {
            types(name)
        }
        function(name) {
            functions(name)
        }
        variable(name) {
            variables(name)
        }
        bindVariable(name, type) {
            variables.set(name, type)
        }
        bindFunction(name, definition) {
            functions.set(name, definition)
        }
        bindTypeVariable(position, id, type) {
            typer.occursCheck(position, id, type, type)
            when(substitution.has(id.toString), { typer.error(position, "Type variable already bound: _\(id.toString)") })
            substitution.set(id.toString, type)
        }
        occursCheck(position, id, outerType, type) {
            typer.expand(type) ? {
                variable(p2, id2) { when(id == id2, { typer.error(position, "Circular type: _\(id.toString) = \(typeToString(typer.expand(outerType)))") }) }
                constructor(p2, symbol2, typeArguments2) { each(typeArguments2, a => typer.occursCheck(position, id, outerType, a)) }
                parameter(p2, name2) {}
            }
        }
        fresh() {
            nextId += 1
            nextId
        }
        expand(type) {
            type ? {
                variable(p2, id2) { substitution.get(id2.toString) ? { some(t) { typer.expand(t) }; none { type } } }
                constructor(p2, symbol2, typeArguments2) { Type.constructor(p2, symbol2, map(typeArguments2, a => typer.expand(a))) }
                parameter(p2, name2) { type }
            }
        }
        instantiate(instantiation, type) {
            type ? {
                variable(position, id) { type }
                parameter(position, name) { type }
                constructor(position, symbol, typeArguments) {
                    Type.constructor(position, symbol, map(typeArguments, t => typer.instantiate(instantiation, t)))
                }
            }
        }
        setModule(newModule) {
            module = newModule
        }
        error(position, problem) {
            moduleName := module.file
            js"console.log('Type error in ' + moduleName + ':')"
            panic("\(problem) \(positionText(newCharCursor(module.source), position))")
        }
    }
}

equalityConstraint(typer : Typer, position : Int, expectedType : Type, actualType : Type) : Void {
    error := {
        typer.error(position, "Expected \(typeToString(typer.expand(expectedType))), got \(typeToString(typer.expand(actualType)))")
    }
    typer.expand(expectedType) ? {
        variable(p1, id1) {
            typer.expand(expectedType) ? {
                variable(p2, id2) {
                    when(id1 != id2, {
                        typer.bindTypeVariable(position, id1, actualType)
                    })
                }
                constructor(p2, symbol2, typeArguments2) { typer.bindTypeVariable(position, id1, actualType) }
                parameter(p2, name2) { typer.bindTypeVariable(position, id1, actualType) }
            }
        }
        constructor(p1, symbol1, typeArguments1) {
            typer.expand(expectedType) ? {
                variable(p2, id2) { typer.bindTypeVariable(position, id2, actualType) }
                constructor(p2, symbol2, typeArguments2) {
                    when(symbol1 != symbol2, { error() })
                    when(typeArguments1.size != typeArguments2.size, { error() })
                    each(zip(typeArguments1, typeArguments2), p => equalityConstraint(typer, position, p.first, p.second))
                }
                parameter(p2, name2) { error() }
            }
        }
        parameter(p1, name1) {
            typer.expand(expectedType) ? {
                variable(p2, id2) { typer.bindTypeVariable(position, id2, actualType) }
                constructor(p2, symbol2, typeArguments2) { error() }
                parameter(p2, name2) {
                    when(name1 != name2, { error() })
                }
            }
        }
    }
}

typeToString(type : Type) : String {
    type ? {
        variable(p2, id2) {
            "_\(id2.toString)"
        }
        constructor(p2, symbol2, typeArguments2) {
            as := map(typeArguments2, a => typeToString(a))
            joined := join(map(typeArguments2, t => typeToString(t)), ", ")
            if(typeArguments2.size == 0, { "\(symbol2)" }, { "\(symbol2)[\(joined)]" })
        }
        parameter(p2, name2) {
            "\(name2)"
        }
    }
}

