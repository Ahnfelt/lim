equalityConstraint(typer : Typer, position : Int, originalExpectedType : Type, originalActualType : Type) : Void {
    error[a]() : a {
        typer.error(position, "Expected \(typeToString(typer.expand(originalExpectedType))), got \(typeToString(typer.expand(originalActualType)))")
    }
    go(expectedType : Type, actualType : Type) : Void {
        typer.expand(expectedType) ? {
            variable(p1, id1) {
                typer.expand(expectedType) ? {
                    variable(p2, id2) {
                        when(id1 != id2, {
                            typer.bindTypeVariable(position, id1, actualType)
                        })
                    }
                    constructor(p2, symbol2, typeArguments2) { typer.bindTypeVariable(position, id1, actualType) }
                    parameter(p2, name2) { typer.bindTypeVariable(position, id1, actualType) }
                }
            }
            constructor(p1, symbol1, typeArguments1) {
                typer.expand(expectedType) ? {
                    variable(p2, id2) { typer.bindTypeVariable(position, id2, actualType) }
                    constructor(p2, symbol2, typeArguments2) {
                        when(symbol1 != symbol2, { error() })
                        when(typeArguments1.length != typeArguments2.length, { error() })
                        each(zip(typeArguments1, typeArguments2), p => go(p.first, p.second))
                    }
                    parameter(p2, name2) { error() }
                }
            }
            parameter(p1, name1) {
                typer.expand(expectedType) ? {
                    variable(p2, id2) { typer.bindTypeVariable(position, id2, actualType) }
                    constructor(p2, symbol2, typeArguments2) { error() }
                    parameter(p2, name2) {
                        when(name1 != name2, { error() })
                    }
                }
            }
        }
    }
    go(originalExpectedType, originalActualType)
}

typeToString(type : Type) : String {
    type ? {
        variable(p2, id2) {
            "_\(id2)"
        }
        constructor(p2, symbol2, typeArguments2) {
            as := map(typeArguments2, a => typeToString(a))
            joined := join(typeArguments2, ", ")
            if(typeArguments2.size == 0, { "\(symbol2)" }, { "\(symbol2)[\(joined)]" })
        }
        parameter(p2, name2) {
            "\(name2)"
        }
    }
}

Typer {
    scope[a](body : () => a) : a
    topScope[a](body : () => a) : a
    type(name : String) : Type
    variable(name : String) : Type
    bindVariable(name : String, type : Type)
    bindTypeVariable(id : Int, type : Type)
    fresh() : Int
    expand(type : Type) : Type
    setModule(newModule : Module)
    error[a](position : Int, problem : String) : a
}

newTyper(modules : Array[Module]) : Typer {
    types := newStringMap([])
    functions := newStringMap([])
    variables := newStringMap([])
    substitution := newStringMap([])
    nextId := 0
    module := modules(0)
    Typer { typer =>
        scope(body) {
            oldVariables := variables.toArray
            result := body()
            variables = newStringMap(oldVariables)
            result
        }
        topScope(body) {
            result := body()
            variables = newStringMap([])
            substitution = newStringMap([])
            nextId = 0
            result
        }
        type(name) {
            types(name)
        }
        variable(name) {
            variables.get(name) ? {
                some(t) { t }
                none { functions(name) }
            }
        }
        bindVariable(name, type) {
            variables.set(name, type)
        }
        bindTypeVariable(position, id, type) {
            go(innerType : Type) {
                typer.expand(innerType) ? {
                    variable(p2, id2) { when(id == id2, { typer.error(position, "Circular type: _\(id) = \(typeToString(type))") }) }
                    constructor(p2, symbol2, typeArguments2) { each(typeArguments2, a => go(a)) }
                    parameter(p2, name2) {}
                }
            }
            go(type)
            when(substitution.has(id.toString), { typer.error(position, "Type variable already bound: _\(id)") })
            substitution.set(id.toString, type)
        }
        fresh() {
            nextId += 1
            nextId
        }
        expand(type) {
            type ? {
                variable(p2, id2) { substitution.get(id2) ? { some(t) { typer.expand(t) }; none { type } } }
                constructor(p2, symbol2, typeArguments2) { Type.constructor(p2, symbol2, map(typeArguments2, a => typer.expand(a))) }
                parameter(p2, name2) { type }
            }
        }
        setModule(newModule) {
            module = newModule
        }
        error(position, problem) {
            moduleName := module.file
            js"console.log('Type error in ' + moduleName + ':')"
            panic("\(problem) \(positionText(newCharCursor(module.source), position))")
        }
    }
}
